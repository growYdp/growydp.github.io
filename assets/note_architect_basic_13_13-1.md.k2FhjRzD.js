import{_ as t,c as o,o as r,a4 as l}from"./chunks/framework.BAVCir-e.js";const S=JSON.parse('{"title":"13-1 软件架构概述-构件技术","description":"","frontmatter":{},"headers":[],"relativePath":"note/architect/basic/13/13-1.md","filePath":"note/architect/basic/13/13-1.md","lastUpdated":1730887577000}'),n={name:"note/architect/basic/13/13-1.md"},s=l('<h1 id="_13-1-软件架构概述-构件技术" tabindex="-1">13-1 软件架构概述-构件技术 <a class="header-anchor" href="#_13-1-软件架构概述-构件技术" aria-label="Permalink to &quot;13-1 软件架构概述-构件技术&quot;">​</a></h1><h2 id="软件架构概述" tabindex="-1">软件架构概述 <a class="header-anchor" href="#软件架构概述" aria-label="Permalink to &quot;软件架构概述&quot;">​</a></h2><ul><li><p><strong>从需求分析到软件设计之间的过渡过程称为软件架构</strong>。</p></li><li><p>架构设计就是<strong>需求分配，将满足需求的职责分配到组件上</strong></p></li><li><p>软件架构为软件系统提供了一个<strong>结构、行为和属性的高级抽象</strong>，由<strong>构件的描述、构件的相互作用（连接件）、指导构件集成的模式以及这些模式的约束</strong>组成。</p></li><li><p>软件架构不仅<strong>指定了系统的组织结构和拓扑结构</strong>，并且显示了<strong>系统需求和构件之间的对应关系</strong>，提供了一些设计决策的基本原理。</p></li><li><p>解决好<strong>软件的复用、质量和维护问题，是研究软件架构的根本目的</strong></p></li><li><p>软件架构设计包括<strong>提出架构模型，产生架构设计和进行设计评审等活动</strong>。是一个迭代的过程。架构设计主要关注<strong>软件组件的结构、属性和交互作用，并通过多种视图全面描述特定系统的架构</strong></p></li><li><p>软件架构能够在设计变更相对容易得阶段，考虑系统结构的可选方案，便于<strong>技术人员与非技术人员就软件设计进行交互</strong>，能够展<strong>现软件的结构。属性与内部交互关系。</strong></p></li><li><p>软件架构是<strong>项目干系人进行交流的手段</strong>，明确了对系统实现的约束条件，决定了开发和维护组织的组织结构，制约着系统的质量属性</p></li><li><p>软件架构<strong>使推理和控制的变更更加简单</strong>，有助于循序渐进的原型设计，可以作为培训的基础</p></li><li><p>软件架构是<strong>可传递和可复用的模型，通过研究软件架构可能预测软件的质量</strong></p></li></ul><h2 id="软件架构设计与生命周期" tabindex="-1">软件架构设计与生命周期 <a class="header-anchor" href="#软件架构设计与生命周期" aria-label="Permalink to &quot;软件架构设计与生命周期&quot;">​</a></h2><ol><li>需求分析阶段。需求分析和SA(软件架构)设计面临的是不同的对象：一个是<strong>问题空间</strong>；另一个是<strong>解空间</strong>。从软件需求模型向SA模型的转换主要关注两个问题：<strong>如何根据需求模型构建SA模型。如何保证模型转换的可追踪性。</strong></li><li>设计阶段。是SA<strong>研究关注的最早和最多的阶段</strong>，这一阶段的SA研究主要包括：<strong>SA模型的描述、SA模型的设计与分析方法，以及对SA设计经验的总结与复用</strong>等。有关SA模型描述的研究分为3个层次：SA的基本概念（构件和连接子，连接子就是连接件）。体系结构描述语言ADL、SA模型的多视图表示。</li><li>实现阶段。最初SA研究往往只关注较高层次的系统设计、描述和验证。为了有效<strong>实现SA设计向实现的转换</strong>，实现阶段的体系结构研究表现在以下几个方面。 <ol><li>研究基于SA的<strong>开发过程支持</strong>，如项目组织结构、配置管理等</li><li>寻求<strong>从SA向实现过渡的途径</strong>，如将程序设计语言元素引入SA阶段、模型映射、构件组装、复用中间件平台等</li><li>研究<strong>基于SA的测试技术</strong></li></ol></li><li>构件组装阶段。在SA设计模型的指导下，可复用构件的组装可以在<strong>较高层次上实现系统</strong>，并能够提高系统实现的效率。在组件组装的过程中，SA设计模型起到了<strong>系统蓝图的作用</strong>。研究内容包括如下两个方面。 <ol><li>如何<strong>支持可复用构件的互联</strong>，即对SA涉及模型中规约的连接子的实现提供支持。</li><li>在组装过程中，<strong>如何检测并消除体系结构适配问题</strong> 在构件组装阶段的适配问题主要包括：</li></ol></li></ol><ul><li>由构件引起的适配</li><li>由连接子引起的适配</li><li>由于系统成分对全局体系结构的假设存在冲突引起的适配等</li></ul><ol start="5"><li>部署阶段。SA对软件部署作用如下。 <ol><li>提供<strong>高层的体系结构视图</strong>来描述部署阶段的软硬件模型</li><li>基于SA模型可以分析部署方案的质量属性，从而选择合理的部署方案。</li></ol></li><li>后开发阶段。是指软件<strong>部署安装之后的阶段</strong>。这一阶段的SA研究主要围绕<strong>维护、演化、复用</strong>等方面来进行。典型的研究方向包括<strong>动态软件体系结构、体系结构恢复与重建</strong>等。 <ol><li>动态软件体系结构。现实中的软件具有动态性，<strong>体系结构会在运行时发生改变</strong>。运行时变化包括两类： <ol><li>软件<strong>内部执行</strong>所导致的体系结构改变</li><li>软件系统<strong>外部的请求</strong>对软件进行的重配置 包括两个部分的研究：</li><li>体系结构<strong>设计阶段的支持</strong></li><li><strong>运行时刻基础设施</strong>的支持</li></ol></li><li><strong>体系结构恢复与重建</strong>。对于现有系统在开发时候<strong>没有考虑SA的情况，从这些系统中恢复或重构体系结构</strong>。从已有的系统中获取体系结构的重建方法分为4类。 <ol><li>手工体系结构重建</li><li>工具支持的手工重建</li><li>通过查询语言来自动建立聚集</li><li>使用其他技术（如数据挖掘等）</li></ol></li></ol></li></ol><h2 id="构件-封装很多功能的函数" tabindex="-1">构件（封装很多功能的函数） <a class="header-anchor" href="#构件-封装很多功能的函数" aria-label="Permalink to &quot;构件（封装很多功能的函数）&quot;">​</a></h2><ul><li>构件是一个<strong>独立可交付的功能单元，外界通过接口访问其提供的服务</strong></li><li>构件<strong>由一组通常需要同时部署的院子构件组成</strong>。一个原子构件是<strong>一个模块和一组资源</strong>。原子构件是<strong>部署、版本控制和替换的基本单位</strong>。原子构件通常成组地部署，但是它也能够被单独部署。</li><li>构件和原子构件之间的区别在于，<strong>大多数原子构件永远都不会被单独部署</strong>，尽管他们可以被单独部署。相反，<strong>大多数原子构件都属于一个构建家族，一次部署往往涉及整个家族。</strong></li><li><strong>一个模块是不带单独资源的原子构件</strong></li><li><strong>一个单独的包被编译成多个单独的类文件</strong>-每个公共类都有一个</li><li><strong>模块是一组类和可能的非面向对象的结构体</strong>，比如过程或者函数</li></ul><h3 id="构件的特性" tabindex="-1">构件的特性 <a class="header-anchor" href="#构件的特性" aria-label="Permalink to &quot;构件的特性&quot;">​</a></h3><ul><li>独立部署单元</li><li>作为第三方的组装单元</li><li>没有（外部的）可见状态</li></ul><p>一个构建可以包含多个类元素，但是一个类元素只能属于一个构件</p><p>讲一个类拆分进行部署通常没什么意义</p><h3 id="对象的特性" tabindex="-1">对象的特性 <a class="header-anchor" href="#对象的特性" aria-label="Permalink to &quot;对象的特性&quot;">​</a></h3><ul><li><strong>一个实例单元</strong>，具有唯一的标志</li><li><strong>可能具有状态</strong>，此状态外部可见</li><li><strong>封装了自己的状态和行为</strong></li></ul><h3 id="构件接口" tabindex="-1">构件接口 <a class="header-anchor" href="#构件接口" aria-label="Permalink to &quot;构件接口&quot;">​</a></h3><p>接口标准化是对接口中<strong>消息的格式、模式和协议的标准化</strong>。它部署要将接口格式化为参数化操作的集合，而是<strong>关注输入输出的消息的标准化</strong>，它强调当机器在网络中互联时，标准的消息模式、格式、协议的重要性。</p><h3 id="面向构件的变成-cop" tabindex="-1">面向构件的变成（COP） <a class="header-anchor" href="#面向构件的变成-cop" aria-label="Permalink to &quot;面向构件的变成（COP）&quot;">​</a></h3><p>关注与<strong>如何支持建立面向构件的解决方案</strong>。“面向构件的变成需要下列基本的支持”：</p><ul><li>多态性（可替代性）</li><li>模块封装性（高层次信息的隐藏）</li><li>后期的绑定和装载（部署独立性）</li><li>安全性（类型和模块安全性）</li></ul><h3 id="构件技术" tabindex="-1">构件技术 <a class="header-anchor" href="#构件技术" aria-label="Permalink to &quot;构件技术&quot;">​</a></h3><p><strong>利用某种编程手段</strong>，将一些人们所关心的，但又不便于让最终用户去直接操作的<strong>细节进行了封装，同时对各种业务逻辑规则进行了实现</strong>，用于处理用户的内部操作细节。</p><p>构件标准流派：</p><ul><li>EJB（Enterprise Java Beans）由Sun公司制定，有三种类型的EJB，分别是<strong>会话Bean（Session Bean）、实体Bean（Entity Bean）和消息驱动Bean（Message driven Bean）。EJB实现应用中关键的业务逻辑，创建基于构件的企业级应用程序。</strong></li><li><strong>COM、DCOM、COM+</strong>： <ul><li><strong>COM是微软公司的</strong></li><li>DCOM是COM的进一步扩展，具有位置独立性和语言无关性</li><li>COM+不是COM的新版本，是COM的新发展或是更高层次的引用</li></ul></li><li><strong>CORBA标准</strong>主要分为三个层次：<strong>对象请求代理、公共对象服务和公共设施</strong>。<strong>最底层是对象请求代理ORB</strong>。规定了分布对象的定义（接口）和语言映射，实现对象间的通讯和互操作，<strong>是分布对象系统中的“软总线”</strong></li></ul><p><strong>在ORB之上定义了很多公共服务</strong>，可以提供诸如并发服务、名字服务、事务（交易）服务、安全服务等各种各样的服务；</p><p><strong>最上层的公共设施则定义了组件框架</strong>，提供可直接为业务对象使用的服务，规定业务对象有效协作所需的协定规则。</p>',26),i=[s];function a(g,e,h,p,c,d){return r(),o("div",null,i)}const _=t(n,[["render",a]]);export{S as __pageData,_ as default};
