import{_ as a,c as t,o as r,a4 as o,aJ as s,aK as n,aL as e,aM as i,aN as l,aO as h}from"./chunks/framework.C3AEaxaX.js";const x=JSON.parse('{"title":"11-1 面向对象基本概念-分析设计测试","description":"","frontmatter":{},"headers":[],"relativePath":"note/architect/basic/11/11-1.md","filePath":"note/architect/basic/11/11-1.md","lastUpdated":null}'),g={name:"note/architect/basic/11/11-1.md"},d=o('<h1 id="_11-1-面向对象基本概念-分析设计测试" tabindex="-1">11-1 面向对象基本概念-分析设计测试 <a class="header-anchor" href="#_11-1-面向对象基本概念-分析设计测试" aria-label="Permalink to &quot;11-1 面向对象基本概念-分析设计测试&quot;">​</a></h1><h2 id="面向对象开发" tabindex="-1">面向对象开发 <a class="header-anchor" href="#面向对象开发" aria-label="Permalink to &quot;面向对象开发&quot;">​</a></h2><h3 id="_1-对象" tabindex="-1">1.对象 <a class="header-anchor" href="#_1-对象" aria-label="Permalink to &quot;1.对象&quot;">​</a></h3><p>由<strong>数据及其操作所构成的封装体</strong>，是系统中用来<strong>描述客观事务的一个实体</strong>，是构成系统的一个基本单位。一个对象通常可以由<strong>对象名、属性和方法</strong>3个部分组成</p><h3 id="_2-类" tabindex="-1">2.类 <a class="header-anchor" href="#_2-类" aria-label="Permalink to &quot;2.类&quot;">​</a></h3><p>现实世界中<strong>实体的形式化描述</strong>，类将该实体的属性（数据）和操作（函数）封装在一起。<strong>对象是类的实例，类是对象的模板</strong>。</p><p>类可以分为三种：<strong>实体类、接口类（边界类）和控制类</strong>。</p><ul><li>实体类：<strong>对象表示现实世界中真实的实体</strong>，如人、物等</li><li>接口类：<strong>为用户提供一种与系统合作交互的方式</strong>。分为人和系统两大类 <ul><li>人的接口可以是显示屏、窗口、web窗体、对话框</li><li>系统的接口涉及把数据发送到其他系统，或者从其他系统接收数据</li></ul></li><li>控制类：对象用来<strong>控制活动流，充当协调者</strong>。</li></ul><h3 id="_3-抽象" tabindex="-1">3.抽象 <a class="header-anchor" href="#_3-抽象" aria-label="Permalink to &quot;3.抽象&quot;">​</a></h3><p>**通过特定的事例抽取共同特征以后形成概念的过程。它强调主要特征，忽略次要特征。**一个对象是现实世界中一个实体的抽象，一个类是一组对象的抽象，抽象是一种单一化的描述，它强调给出与应用相关的特性，抛弃不相关的特性。</p><h3 id="_4-封装" tabindex="-1">4.封装 <a class="header-anchor" href="#_4-封装" aria-label="Permalink to &quot;4.封装&quot;">​</a></h3><p><strong>是一种信息隐蔽技术</strong>，将相关的概念组成一个单元模块，并通过一个名称来引用。面向对象封装是将数据和基于数据的操作封装成一个整体对象，对数据的访问或修改只能通过对象对外提供的接口进行</p><h3 id="_5-继承" tabindex="-1">5.继承 <a class="header-anchor" href="#_5-继承" aria-label="Permalink to &quot;5.继承&quot;">​</a></h3><p>表示<strong>类之间的层次关系（父类与子类）</strong>，这种关系使得某类对象可以继承另外一类对象的特征，可分为单继承和多继承。</p><h3 id="_6-多态" tabindex="-1">6.多态 <a class="header-anchor" href="#_6-多态" aria-label="Permalink to &quot;6.多态&quot;">​</a></h3><p><strong>不同的对象收到同一个消息时产生完全不同的结果</strong></p><ul><li><strong>参数多态 不同类型参数多种结构类型</strong></li><li><strong>过载多态 类似于重载，一个名字不同含义</strong></li><li><strong>强制多态 强制类型转换</strong></li><li><strong>包含多态 父子类型关系</strong></li></ul><p>多态由继承机制支持，将通用消息放在抽象层，具体不同的功能放在低层。</p><h3 id="_7-接口" tabindex="-1">7.接口 <a class="header-anchor" href="#_7-接口" aria-label="Permalink to &quot;7.接口&quot;">​</a></h3><p>描述对操作规范的说明，<strong>其只说明操作应该做什么</strong>，并没有定义操作如何做。</p><h3 id="_8-消息" tabindex="-1">8.消息 <a class="header-anchor" href="#_8-消息" aria-label="Permalink to &quot;8.消息&quot;">​</a></h3><p><strong>体现对象间的交互</strong>，通过它向目标对象发送操作请求</p><h3 id="_9-覆盖" tabindex="-1">9.覆盖 <a class="header-anchor" href="#_9-覆盖" aria-label="Permalink to &quot;9.覆盖&quot;">​</a></h3><p>子类在原有父类接口的基础上，用<strong>适合于自己要求的实现去置换父类中的相应实现</strong>。即在子类中重定义一个与父类同名同参的方法</p><h3 id="_10-函数重载" tabindex="-1">10.函数重载 <a class="header-anchor" href="#_10-函数重载" aria-label="Permalink to &quot;10.函数重载&quot;">​</a></h3><p>与覆盖区分开，函数重载与子类父类无关，且函数是<strong>同名不同参数</strong></p><h3 id="_11-绑定" tabindex="-1">11.绑定 <a class="header-anchor" href="#_11-绑定" aria-label="Permalink to &quot;11.绑定&quot;">​</a></h3><p><strong>把过程调用和响应调用所需要执行的代码加以结合</strong>的过程。在一般的程序设计语言中，<strong>绑定是在编译时进行的，叫做静态绑定。动态绑定是在运行时进行的。</strong></p><h3 id="考试真题" tabindex="-1">考试真题 <a class="header-anchor" href="#考试真题" aria-label="Permalink to &quot;考试真题&quot;">​</a></h3><p><img src="'+s+'" alt=""></p><p>答案：A</p><p><img src="'+n+'" alt=""></p><p>答案：B A</p><h3 id="面向对象的分析" tabindex="-1">面向对象的分析 <a class="header-anchor" href="#面向对象的分析" aria-label="Permalink to &quot;面向对象的分析&quot;">​</a></h3><p>是为了<strong>确定问题域，理解问题</strong>。包含五个活动：<strong>认定对象、组织对象、描述对象间的相互作用、确定对象的操作、定义对象的内部信息。</strong></p><h3 id="面向对象需求建模" tabindex="-1">面向对象需求建模 <a class="header-anchor" href="#面向对象需求建模" aria-label="Permalink to &quot;面向对象需求建模&quot;">​</a></h3><p><img src="'+e+'" alt=""></p><p>分析模型又称为领域模型</p><h3 id="面向对象的设计" tabindex="-1">面向对象的设计 <a class="header-anchor" href="#面向对象的设计" aria-label="Permalink to &quot;面向对象的设计&quot;">​</a></h3><p>是<strong>设计分析模型和实现相应源代码</strong>。设计问题域的解决方案，与技术相关。OOD同样应遵循抽象、信息屏蔽、功能独立、模块化等设计准则。</p><p>面向对象的<strong>分析模型</strong>主要由<strong>顶层架构图、用例与用例图、领域概念模型构成</strong>；<strong>设计模型则包含以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、针对复杂对象的状态图和用以描述流程化处理过程的活动图等。</strong></p><p><img src="'+i+'" alt=""></p><h3 id="面向对象的设计原则" tabindex="-1">面向对象的设计原则 <a class="header-anchor" href="#面向对象的设计原则" aria-label="Permalink to &quot;面向对象的设计原则&quot;">​</a></h3><ol><li><strong>单一责任原则</strong>。就一个类而言，应该<strong>仅有一个引起它变化的原因</strong>。即，当需要修改某个类的时候原因只有一个，让一个类只做一种类型责任。</li><li><strong>开放-封闭原则</strong>。软件实体（类、模块、函数等）应该是<strong>可以扩展的，即开放的；但是不可修改的，即封闭的。</strong></li><li><strong>里氏替换原则</strong>。<strong>子类型必须能够替换掉他们的基类型</strong>。即，在任何父类可以出现的地方，都可以用子类的实例来赋值给父类型的引用。</li><li><strong>依赖倒置原则。抽象不应该依赖于细节，细节应该依赖于抽象</strong>。即，高层模块不应该依赖于低层模块。二者都应该依赖于抽象。</li><li><strong>接口分离原则</strong>。不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构。即：<strong>依赖于抽象，不要依赖于具体</strong>，同时在抽象级别不应该有对于细节的依赖。这样的好吃就在于可以最大限度地应对可能的变化。</li></ol><h3 id="面向对象软件的测试" tabindex="-1">面向对象软件的测试 <a class="header-anchor" href="#面向对象软件的测试" aria-label="Permalink to &quot;面向对象软件的测试&quot;">​</a></h3><ol><li><strong>算法层</strong>：测试<strong>类中定义的每个方法</strong>，基本上相当于传统软件测试中的单元测试</li><li><strong>类层</strong>：测试封装在<strong>同一个类中的所有方法和属性之间的相互作用</strong>。在面向对象软件中类是基本模块，因此可以认为这是面向对象测试中所特有的模块测试。</li><li><strong>模板层</strong>：测试<strong>一组协同工作的类之间的相互作用</strong>，大体上相当于传统软件测试中的集成测试，但是也有面向对象软件的特点（例如：对象之间通过发送消息相互作用）。</li><li><strong>系统层</strong>：把<strong>各个子系统组装成完整的面向对象软件系统</strong>，在组装过程中同时进行测试。</li></ol><h3 id="考试真题-1" tabindex="-1">考试真题 <a class="header-anchor" href="#考试真题-1" aria-label="Permalink to &quot;考试真题&quot;">​</a></h3><p><img src="'+l+'" alt=""></p><p>答案：B C D</p><p><img src="'+h+'" alt=""></p><p>答案：D</p>',51),c=[d];function p(_,u,b,m,q,f){return r(),t("div",null,c)}const k=a(g,[["render",p]]);export{x as __pageData,k as default};
