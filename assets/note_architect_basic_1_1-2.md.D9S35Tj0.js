import{_ as t,c as o,o as l,a4 as e}from"./chunks/framework.BbvukzJZ.js";const d=JSON.parse('{"title":"1-2 指令系统-存储系统-cache","description":"","frontmatter":{},"headers":[],"relativePath":"note/architect/basic/1/1-2.md","filePath":"note/architect/basic/1/1-2.md","lastUpdated":1729501307000}'),n={name:"note/architect/basic/1/1-2.md"},a=e('<h1 id="_1-2-指令系统-存储系统-cache" tabindex="-1">1-2 指令系统-存储系统-cache <a class="header-anchor" href="#_1-2-指令系统-存储系统-cache" aria-label="Permalink to &quot;1-2 指令系统-存储系统-cache&quot;">​</a></h1><h2 id="指令系统" tabindex="-1">指令系统 <a class="header-anchor" href="#指令系统" aria-label="Permalink to &quot;指令系统&quot;">​</a></h2><ul><li>计算机指令系统由两部分组成：一条指令由操作码和操作数两部分组成，操作码决定要完成的操作。操作数指的是参加运算的数据及其所在的单元地址。</li><li>在计算机中，操作要求和操作数地址都由二进制数码表示，分别称为操作码和地址码，整条指令以二进制编码的形式存放在存储器中。</li><li>计算机指令的执行过程：<strong>取指令</strong>→<strong>分析指令</strong>→<strong>执行指令</strong>三个步骤，首先将程序计数器PC中的指令地址取出，送入地址总线，CPU根据指令地址去内存中取出指令内容存入指令寄存器IR；而后由指令译码器进行分析，分析指令操作码；最后执行指令，取出执行指令所需的源操作数。</li></ul><blockquote><p><strong>指令寻址方式</strong></p></blockquote><ul><li>顺序寻址方式：当执行一段程序时，是一条指令接着一条执行的顺序执行。</li><li>跳跃寻址方式：指下一条指令的地址码不是由程序计数器PC给出，而是由本条指令直接给出。程序跳跃后，按新的指令地址开始顺序执行。因此，<strong>程序计数器的内容也要改变，以便及时跟踪新的指令地址。</strong></li></ul><blockquote><p><strong>指令操作数寻址方式</strong></p></blockquote><ul><li><strong>立即寻址方式</strong>：指令的地址码字段指出的不是地址，而是操作数本身。</li><li><strong>直接寻址方式</strong>：在指令的地址字段中直接指出操作数在主存中的地址。</li><li><strong>间接寻址方式</strong>：指令地址码字段所指向存储单元中存储的是操作数的地址。</li><li><strong>寄存器寻址方式</strong>：指令中的地址码是寄存器的编号</li><li><strong>基址寻址方式</strong>：将基址寄存器的内容加上指令中的形式地址而形成操作数的有效地址，其优点是可以扩大寻址能力。</li><li><strong>变址寻址方式</strong>：变址寻址方式计算有效地址的方法与基址寻址方式很相似，它是将变址寄存器的内容加上指令中的形式地址而形成操作数的有效地址。</li></ul><p>CISC是<strong>复杂指令系统</strong>（Complex Instruction Set Computer,CISC），兼容性强、指令繁多、长度可变，由微程序实现；</p><p>RISC是<strong>精简指令系统</strong>，指令少，使用频率接近，主要依靠硬件实现（通用寄存器，硬布线逻辑控制）</p><p>区别：</p><table tabindex="0"><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>指令系统类型</td><td>指令</td><td>寻址方式</td><td>实现方式</td><td>其他</td></tr><tr><td>CISC（复杂）</td><td>数量多，使用频率差别大，可变长格式</td><td>支持多种</td><td>微程序控制技术（微码）</td><td>研制周期长</td></tr><tr><td>RISC（精简）</td><td>数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内容</td><td>支持方式少</td><td>增加了通用寄存器，硬布线逻辑控制为主，适合采用流水线</td><td>优化编译，有效支持高级语言</td></tr></tbody></table><h3 id="考试真题" tabindex="-1">考试真题 <a class="header-anchor" href="#考试真题" aria-label="Permalink to &quot;考试真题&quot;">​</a></h3><blockquote><p>Flynn分类法根据计算机在执行程序的过程中（）的不同组合，将计算机分为4类，当前主流的多核计算机属于（）计算机</p></blockquote><p>A.指令流和数据流 B.数据流和控制流 C.指令流和控制流 D.数据流和总线带宽</p><p>A.SISD B.SIMD C.MISD D.MIMD</p><p>答案：A D</p><blockquote><p>以下关于复杂指令集计算机CISC的叙述中，正确的是（）</p></blockquote><p>A.只设置使用频率高的一些简单指令，不同指令执行时间差别很小</p><p>B.CPU中设置大量寄存器，利用率低</p><p>C.常采用执行速度更快的组合逻辑实现控制器</p><p>D.指令长度不固定，指令格式和寻址方式多</p><p>答案：D</p><ul><li>指令流水线原理：<strong>指令分成不同段，每段由不同的部分去处理</strong>，因此可以产生叠加的效果，所有的部件去处理指令的不同段</li><li>RISC中的流水线技术： <ul><li>超流水线（Super Pipe Line）技术：以时间换取空间</li><li>超标量（Super Scalar）技术：以空间换取时间</li><li>超长指令字（Very Long Instruction Word， VLIW）技术：发挥软件的作用</li></ul></li></ul><blockquote><p>流水线时间计算</p></blockquote><ul><li>流水线周期：指令分成不同执行段，其中<strong>执行时间最长的段为流水线周期</strong></li><li>流水线执行时间：<strong>1条指令执行总时间 + (总指令条数 - 1) * 流水线周期</strong></li><li>流水线吞吐率计算：吞吐率是单位时间内执行的指令条数。<strong>指令条数 / 流水线执行时间</strong></li><li>流水线加速比计算：加速比即使用流水线后的效率提升度，即比不使用流水线快了多少倍，越高表明流水线效率越高。<strong>不使用流水线执行时间 / 使用流水线执行时间</strong></li></ul><h3 id="考试真题-1" tabindex="-1">考试真题 <a class="header-anchor" href="#考试真题-1" aria-label="Permalink to &quot;考试真题&quot;">​</a></h3><blockquote><p>流水线的吞吐率是指流水线在单位时间里所完成的任务数或输出的结果数。设某流水线有5段，有一段的时间是2ns，另外4段每段执行时间为1ns，利用此流水线执行100个任务的吞吐率约为（）s</p></blockquote><p>A. 500 * <em>10^6 B.490</em> * 10^6 C.250 * 10^6 D.167 * 10^6</p><p>解析：</p><p>这道题问吞吐率，其公式为：指令条数 / 流水线执行时间。</p><p>流水线执行时间公式：1条指令执行总时间 + (总指令条数 - 1) * * 流水线周期。*</p><p><em>流水线周期的定义是执行时间最长的段。</em></p><p>*上面题目共有5段流水线，执行时间最长的段是2ns。我们把已知条件带入公式后：2ns + 1ns 4 + (100 - 1) 2 = 204ns。即吞吐率计算时注意ns和s的单位转换，1s = 10^-9ns。即100 / 204 ** 10^-9</p><p>答案：B</p><blockquote><p>假设磁盘块与缓冲区大小相同，每个盘块读入缓冲区的时间为15us，由缓冲区送至用户区的时间是5us，在用户区内系统对每块数据的处理时间为1us，若用户需要将大小为10个磁盘块的Doci文件逐块从磁盘读入缓冲区，并送至用户区进行处理，那么采用单缓冲区需要花费的时间为（）us，采用双缓冲区需要花费的时间为（）us</p></blockquote><p>A.150 B.151 C.156 D.201</p><p>A.150 B.151 C.156 D.201</p><p>解析：</p><p>上面从盘块读入缓冲区的时间是第一段</p><p>缓冲区送至用户区的时间是第二段</p><p>用户区内系统对每块数据的处理时间是第三段</p><p>三段式针对双缓冲区，<strong>双缓冲区执行第二段时下一个磁盘块的第一段可以执行</strong>，用户区不属于缓冲区。套用公式：(15+5+1)+(10-1)*15</p><p>单缓冲区第一段和第二段任务不能并行，也就是执行周期为第一段+第二段的时间，套用公式：(15+5+1)+(10-1)*20</p><p>答案：D C</p><blockquote><p>流水线技术是用过并行硬件来提高系统性能的常用方法。对于一个K段流水线，假设其各段的执行时间均相等（设为t），输入到流水线中的任务是连续的理想情况下，完成n个连续任务需要的总时间为（）。若某流水线浮点加法运算器分为5段，所需要的时间分别是6ns、7ns、8ns、9ns和6ns，则其最大加速比为（）</p></blockquote><p>A. nkt B.(k+n-1)t C.(n-k)kt D.(k+n+1)t</p><p>A.4 B.5 C.6 D.7</p><p>解析：</p><p>一步一步看，第一个问题是完成n连续任务需要的总时间为，我们套用公式：kt+(n-1)t。答案选B</p><p>第二问假设有n个任务，问最大加速比，套用加速比公式：不使用流水线时间/使用流水线时间。一点一点分析，问题中没有告诉我们有几个任务，前面我们已经假设有n条，如果不使用流水线，那么执行逻辑是执行完前一个任务才执行后面的任务，周期就是执行这个任务的总时长6+7+8+9+6=36ns。执行n个总时长为36n。</p><p>使用流水线需要的时间为：36+(n-1)*9 = (3+n)9。</p><p>套用最大加速比公式36n / (3 + n)9 = 4n / 3 + n，n趋于无穷大时，3可以省略，4n / n = 4</p><p>答案：B A</p><h2 id="存储系统" tabindex="-1">存储系统 <a class="header-anchor" href="#存储系统" aria-label="Permalink to &quot;存储系统&quot;">​</a></h2><ul><li>计算机采用分级存储体系的主要目的是为了解决存储容量、成本和速度之间的矛盾问题</li><li>两级存储： <ul><li>Cache - 主存</li><li>主存 - 辅存（虚拟存储体系）</li></ul></li><li>局部性原理：在CPU运行时，所访问的数据会趋向于一个较小的局部空间地址内，包括下面两个方面： <ul><li>时间局部性原理：如果一个数据项正在被访问，那么在近期它很可能会被再次访问，即在<strong>相邻时间里会访问同一个数据项</strong></li><li>空间局部性原理：在最近的将来会用到的数据地址和想在正在访问的数据地址很可能是相近的，<strong>相邻的空间地址会被连续访问</strong></li></ul></li></ul><blockquote><p>内存大小从小到大排序</p></blockquote><ul><li>CPU内部通用寄存器 <ul><li>Cache MB级别 <ul><li>主存储器 <ul><li>联机磁盘存储器 <ul><li>脱机光盘，磁盘存储器</li></ul></li></ul></li></ul></li></ul></li></ul><p><strong>寄存器大小一般是32bit或64bit，越往下容量越来越大，速度越来越慢，越来越便宜。</strong></p><h3 id="cache" tabindex="-1">Cache <a class="header-anchor" href="#cache" aria-label="Permalink to &quot;Cache&quot;">​</a></h3><ul><li>高速缓存Cache用来<strong>存储当前最活跃的程序和数据，直接与CPU交互</strong>，位于CPU和主存之间，容量小，速度为内存的5-10倍，由半导体材料构成。</li><li><strong>Cache的内容是主存内存的副本拷贝。</strong></li><li>Cache由控制部分和存储器组成，存储器存储数据，控制部分判断CPU要访问的数据是否存在Cache中，如果存在则命中，不存在则依据一定的算法从主存中替换。</li><li>地址映射：在CPU工作时，<strong>送出的是主存单元的地址，而应从Cache存储器中读、写信息</strong>。这就需要<strong>将主存地址转换为Cache存储器地址</strong>，这种地址的转换称为地址映像，由<strong>硬件自动完成映射</strong>。</li></ul><blockquote><p>映射方式</p></blockquote><ul><li>直接映像：将<strong>Cache存储器等分成块，主存也等分成块并编号</strong>。主存中的块与Cache中的块的对应关系是固定的，<strong>也即两者块号相同才能命中</strong>。地址变换简单但是不灵活，容易造成资源浪费。</li><li>全相联映像：同样都等分成块并编号。<strong>主存中任意一块都与Cache中任意一块对应。因此可以随意调入Cache任意位置</strong>，但地址变换复杂，速度较慢。因为主存可以随意调入Cache任意块，只有当Cache满了才会发生块冲突。<strong>是最不容易发生块冲突的映像方式</strong>。</li><li>组组相联映像：前面两种方式的结合，将Cache存储器先分块再分组，主存也同样先分块再分组，<strong>组间采用直接映像，即主存中组号与Cache中组号相同的组才能命中，但是组内全相联映像，即组号相同的两个组内的所有块可以任意调换。</strong></li></ul><blockquote><p>替换算法</p></blockquote><p>替换算法的目标是使Cache获得尽可能高的命中率，常用的算法：</p><ol><li>随机替换算法，就是用随机数发生器产生一个要替换的块号，将该块替换出去</li><li>先进先出算法：将最先进入Cache的信息块替换出去</li><li>近期最少使用算法：将近期使用最少的Cache中的信息块替换出去（根据局部性原理，即时间和空间两个维度）</li><li>优化替换算法：这种方法必须先执行一次程序，统计Cache的替换情况，有了这样的先验信息，在第二次执行该程序时可以用最有效的方式来替换</li></ol><blockquote><p>命中率及平均时间</p></blockquote><p>Cache有一个命中率的概念，<strong>即当CPU所访问的数据在Cache中时，命中，直接从Cache中读取数据。</strong></p><p>设读取一次Cache的时间为1ns，<strong>若CPU访问的数据不在Cache中，则需要从内存中读取</strong>，设读取一次内存的时间为1000ns，若在CPU多次读取数据过程中，有90%命中Cache，则ZPI读取一次的平均时间为(90%*1 + 10%*1000)ns</p><blockquote><p>怎么提升命中率呢</p></blockquote><p>当然是Cache容量越大，命中率越高，比如主存只有8G，Cache有8G，那么命中率就是100%。但是Cache提升容量很难的。</p><h3 id="考试真题-2" tabindex="-1">考试真题 <a class="header-anchor" href="#考试真题-2" aria-label="Permalink to &quot;考试真题&quot;">​</a></h3><blockquote><p>按照Cache地址映像的块冲突概率，从高到低排列的是（）</p></blockquote><p>A.全相联映像→直接映像→组组相连映像</p><p>B.直接映像→组组相连映像→全相联映像</p><p>C.组组相连映像→全相联映像→直接映像</p><p>D.直接映像→全相联映像→组组相连映像</p><p>答案：B</p><blockquote><p>以下关于Cache与主存间地址映射的叙述中，正确的是（）</p></blockquote><p>A.操作系统负责管理Cache与主存之间的地址映射</p><p>B.程序员需要通过编程来处理Cache与主存之间的地址映射</p><p>C.应用软件对Cache与主存之间的地址映射进行调度</p><p><strong>D.由硬件自动完成Cache与主存之间的地址映射</strong></p><p>答案：D</p>',83),p=[a];function r(i,s,c,h,u,C){return l(),o("div",null,p)}const b=t(n,[["render",r]]);export{d as __pageData,b as default};
