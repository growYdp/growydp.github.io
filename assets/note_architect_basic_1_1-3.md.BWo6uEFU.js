import{_ as t,c as d,o as r,a4 as a}from"./chunks/framework.BzzsfKfI.js";const m=JSON.parse('{"title":"1-3 磁盘-输入输出技术-总线","description":"","frontmatter":{},"headers":[],"relativePath":"note/architect/basic/1/1-3.md","filePath":"note/architect/basic/1/1-3.md","lastUpdated":1729501307000}'),o={name:"note/architect/basic/1/1-3.md"},s=a('<h1 id="_1-3-磁盘-输入输出技术-总线" tabindex="-1">1-3 磁盘-输入输出技术-总线 <a class="header-anchor" href="#_1-3-磁盘-输入输出技术-总线" aria-label="Permalink to &quot;1-3 磁盘-输入输出技术-总线&quot;">​</a></h1><h2 id="磁盘" tabindex="-1">磁盘 <a class="header-anchor" href="#磁盘" aria-label="Permalink to &quot;磁盘&quot;">​</a></h2><h3 id="磁盘结构和参数" tabindex="-1">磁盘结构和参数 <a class="header-anchor" href="#磁盘结构和参数" aria-label="Permalink to &quot;磁盘结构和参数&quot;">​</a></h3><p>磁盘<strong>有正反两个磁面，每个盘面有多个同心圆，每个同心圆是一个磁道，每个同心圆又被划分为多个扇区，数据就被存放在一个个扇区中。</strong></p><p><strong>磁头首先要寻找到相应的磁道</strong>，然后等待磁盘进行<strong>周期旋转，旋转到指定的扇区，才能读取到对应的数据</strong>。因此，会产生<strong>寻道时间和等待时间</strong>。公式为：存取时间=寻道时间+等待时间（平均定位时间+转动延迟）</p><p><strong>寻道时间是指磁头移动到磁道所需的时间；等待时间为等待读写的扇区转到磁头下方所用的时间。</strong></p><h3 id="磁盘调度算法" tabindex="-1">磁盘调度算法 <a class="header-anchor" href="#磁盘调度算法" aria-label="Permalink to &quot;磁盘调度算法&quot;">​</a></h3><p>磁盘数据的读取时间为寻道时间+旋转时间</p><p>也就是先找到对应的磁道，而后再旋转到对应的扇区才能读取数据，其中<strong>寻道时间耗时最长</strong>，需要重点调度，调度算法如下：</p><ul><li>先来先服务FCFS：根据进程请求访问磁盘的先后顺序进行调度</li><li>最短寻道时间优先SSTF：请求访问的磁道与当前磁道最近的进程优先调度，使得每次的寻道时间最短，会产生饥饿现象，即远处进程可能永远无法访问。</li><li>扫描算法SCAN：电梯算法，磁头在磁盘上双向移动，其会选择离磁头当前所在磁道最近的请求访问的磁道，并且与磁头移动方向一致，磁头永远都是从里向外或者从外向里一直移动完才掉头，与电梯类似。</li><li>单向扫描调度算法CSCAN：与SCAN不同的是，其只做单向移动，即只能从里向外或者从外向里</li></ul><h3 id="考试真题" tabindex="-1">考试真题 <a class="header-anchor" href="#考试真题" aria-label="Permalink to &quot;考试真题&quot;">​</a></h3><blockquote><p>假设某磁盘的每个磁道划分成11个物理块，每块存放1个逻辑记录，逻辑记录R0,R1....R9,R10存放在同一个磁道上，记录的存放顺序如下：</p></blockquote><table tabindex="0"><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>物理块</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td></tr><tr><td>逻辑记录</td><td>R0</td><td>R1</td><td>R2</td><td>R3</td><td>R4</td><td>R5</td><td>R6</td><td>R7</td><td>R8</td><td>R9</td><td>R10</td></tr></tbody></table><p>如果磁盘的旋转周期为33ms，磁头当前处在R0的开始处，若系统使用单缓冲区顺序处理这些记录，每个记录处理时间为3ms，则处理这11个记录的最长时间为（）；若对信息存储进行优化分布后，处理11个记录的最少时间为（）</p><p>A.33ms B.336ms C.366ms D.376ms</p><p>A.33ms B.66ms C.86ms D.93ms</p><p>解析：</p><p>本题不需要寻道，因为磁头已经在R0了。</p><p>读一个物理块需要3ms，处理一个物理块需要3ms</p><p>在R0磁头转3ms，磁头到R1。此时处理R0,读取+处理R0花了6ms，此时磁头已经到R2了，要读取R1还需要磁头再旋转到R1，再旋转10个扇区磁头才又返回R1</p><p>3 + 3 + (10**3 + 3 + 3)**10 = 366</p><p>第二问优化分布，既然处理一个物理块需要6ms，此时磁头旋转了两个物理块，那么优化方法就是R0 R6 R1 R7 R2 R8 R3 R9 R4 R10 R5，处理1个物理块6ms，处理11个需要66ms</p><p>答案：C B</p><blockquote><p>在磁盘调度管理中，应先进性移臂调度，再进行旋转调度，假设磁盘移动臂位于21号柱面上，进程的请求序列如下表所示，如果采用最短移臂调度算法，那么系统的响应序列应为（）</p></blockquote><table tabindex="0"><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>请求序列</td><td>柱面号</td><td>磁头号</td><td>扇区号</td></tr><tr><td>1</td><td>17</td><td>8</td><td>9</td></tr><tr><td>2</td><td>23</td><td>6</td><td>3</td></tr><tr><td>3</td><td>23</td><td>9</td><td>6</td></tr><tr><td>4</td><td>32</td><td>10</td><td>5</td></tr><tr><td>5</td><td>17</td><td>8</td><td>4</td></tr><tr><td>6</td><td>32</td><td>3</td><td>10</td></tr><tr><td>7</td><td>17</td><td>7</td><td>9</td></tr><tr><td>8</td><td>23</td><td>10</td><td>4</td></tr><tr><td>9</td><td>38</td><td>10</td><td>8</td></tr></tbody></table><p>A.2 8 3 4 5 1 7 6 9</p><p>B.2 3 8 4 6 9 1 5 7</p><p>C.1 2 3 4 5 6 7 8 9</p><p>D.2 8 3 5 7 1 4 6 9</p><p>解析：</p><p>题中提到最短移臂调度算法，即最短寻道算法，现在移动臂在21号柱面，表格中离21号最近的是23号柱面，序列分别为2 3 8,然后根据扇区号进行排序，最后得到的序列是2 8 3,排除B C。</p><p>然后寻找举例23号柱面最近的柱面为17号，序列号为1 5 7,再根据扇区号进行排序，得到的序列为5 7 1。</p><p>答案：D</p><h3 id="输入输出技术" tabindex="-1">输入输出技术 <a class="header-anchor" href="#输入输出技术" aria-label="Permalink to &quot;输入输出技术&quot;">​</a></h3><p>计算机系统中存在多种内存与接口地址的编址方法</p><ol><li>内存与接口地址独立编址方法</li></ol><p>内存地址和接口地址是<strong>完全独立的两个地址空间</strong>，<strong>访问数据时所使用的指令也完全不同</strong>，用于接口的指令只用于接口的读、写，其余的指令全都是用于内存的。</p><p><strong>缺点：用于接口的指令太少、功能太弱</strong></p><ol><li>内存与接口地址统一编址方法</li></ol><p>内存地址和接口地址<strong>统一在一个公共的地址空间里</strong>，即内存单元和接口共用地址空间，优点是原则上用于内存的指令全都可以用于接口，大大的增强了对接口的操作功能，在指令上也不再区分内存或接口指令。</p><p>**缺点：整个地址空间被分成两部分，**一部分分配给接口使用，剩余的为内存所用。，经常会导致内存地址不连续。</p><p>计算机和外设间的数据交互方式：</p><ul><li>程序控制（查询）方式：<strong>CPU主动查询外设是否完成数据传输，效率极低。</strong></li><li>程序中断方式：外设完成数据传输后，<strong>向CPU发送中断</strong>，等待CPU处理数据，效率相对较高。<strong>中断响应时间</strong>指的是从发出中断请求到开始进入中断处理程序；<strong>中断处理时间</strong>指的是从中断处理开始到中断处理结束。<strong>中断向量</strong>提供中断服务程序的入口地址。多级中断嵌套，使用堆栈来保护断点和现场。</li><li>DMA方式（直接主存存取）：<strong>CPU只需要完成必要的初始化等操作，数据传输的整个过程都由DMA控制器来完成，在主存和外设之间建立直接的数据通路，效率很高</strong></li><li>在<strong>一个总线周期结束后，CPU会响应DMA请求开始读取数据；CPU响应程序中断方式请求是在一条指令执行结束时。</strong></li></ul><h3 id="总线结构" tabindex="-1">总线结构 <a class="header-anchor" href="#总线结构" aria-label="Permalink to &quot;总线结构&quot;">​</a></h3><ul><li>总线（Bus），是指计<strong>算机设备和设备之间传输信息的公共数据通道</strong>。总线是连接计算机硬件系统内多种设备的通信线路，它的一个重要特征是<strong>由总线上的所有设备共享</strong>，因此可以将计算机系统内的多种设备连接到总线上。</li><li>广义上讲，任何连接两个以上电子元器件的的导线都可以称为总线，通常分为 <ul><li>内部总线：内部芯片级别的总线，芯片与处理器之间通信的总线</li><li>系统总线：是板级总线，用于计算机内各部分之间的连接，具体分为<strong>数据总线（并行数据传输位数）、地址总线（系统可管理的内存空间的大小）、控制总线（传送控制命令）</strong>。代表的有ISA总线、ELSA总线、PCI总线。</li><li>外部总线：设备一级的总线，微机和外部设备的总线。代表的有RS232（串行总线）、SCSI（并行总线）、USB（通用穿行总线，即插即用，支持热插拔）</li></ul></li></ul>',45),e=[s];function l(n,h,i,p,c,g){return r(),d("div",null,e)}const u=t(o,[["render",l]]);export{m as __pageData,u as default};
